#### 1、为什么要用消息中间件

​       **实现系统的解耦，多个系统间通过消息中间件进行异步通信**

#### 2、**RabbitMQ运作流程**

​        **Virtual Host** : 每个virtual host本质上都是一个RabbitMQ Server（但是一个server中可以有多个virtual   host），拥有它自己若干的个Exchange、Queue和bings rule等等，类似于权限控制组。Virtual Host是权限控制的最小粒度。

​        **Connection :** 一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的

​        **Connection :** 一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的

#### 1、RabbitMQ 实现消息顺序（消息时序）

1. 为什么会出现消息一致性问题
   - 多个客户端之间都是使用的本地时钟，而没有一个所谓的“全局时钟”，所以不能用“本地时间”来完全决定消息的时序
   - 多服务器不能用“本地时间”进行比较，即使是一台服务器的本地时间，也无法表示“绝对时序，因为存在网络延迟问题
   - 由于多个接收方的存在，无法用发送方的本地时间，表示“绝对时序”
   - 消费者本地多线程的存在，也不能保证绝对的时序

#### 2、优化实践

- **以客户端或者服务端的时序为准**
  - 邮件展示顺序，其实是以客户端发送时间为准的，潜台词是，发送方只要将邮件协议里的时间调整为1970年或者2970年，就可以在接收方收到邮件后一直“置顶”或者“置底”
  - 秒杀活动时间判断，肯定得以服务器的时间为准，不可能让客户端修改本地时间，就能够提前秒杀

- **服务端能够生成单调递增的id、利用单点写db的seq/auto_inc_id肯定能生成单调递增的id，只是说性能及扩展性会成为潜在瓶颈**
  - 大部分业务，长时间趋势递增的时序就能够满足业务需求，非常短时间的时序误差一定程度上能够接受。
  - 绝对递增id，趋势递增id（要求 **全局唯一、趋势有序**）

**分布式 ID 生成方法：**

- **常见方法一：使用数据库的 auto_increment 来生成全局唯一递增ID**
  - 优点：
    - 能够保证唯一性
    - 能够保证递增性
    - 步长固定
    - 简单，使用数据库已有的功能
  - 缺点：
    - 常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了
    - 写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展
- 改进方法
  - 增加主库，避免写入单点
  - 数据水平切分，保证各主库生成的ID不重复
  - 优点：
    - 保证了可用性
  - 缺点：
    - 丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内
    - 数据库的写压力依然很大，每次生成ID都要访问数据库

- **常见方法二：单点批量ID生成服务**

  ![image-20200903164613395](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20200903164613395.png)

  - 数据库使用**双master保证可用性**，**数据库中只存储当前ID的最大值**，例如0。ID生成服务假设**每次批量拉取6个ID，服务访问数据库，将当前ID的最大值修改为5**，这样**应用访问ID生成服务索要ID**，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4,5这些ID了，当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是**数据库的压力就降低到原来的1/6了**
    - 优点：
      - 保证了ID生成的绝对递增有序
      - 大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个
    - 缺点：
      - 服务仍然是单点
      - 服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞
      - 毕竟还是有性能上限，无法进行水平扩展
  - 改进方法：
    - 对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。这个切换的过程对调用方是透明的，可以自动完成，常用的技术是vip+keepalived

- **常见方法三：uuid**
  - 优点：
    - 本地生成ID，不需要进行远程调用，时延低
    - 扩展性好，基本可以认为没有性能上限
  - 缺点：
    - 无法保证趋势递增
    - uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）
- **常见方法四：取当前毫秒数**
  - 优点：
    - 本地生成ID，不需要进行远程调用，时延低
    - 生成的ID趋势递增
    - 生成的ID是整数，建立索引后查询效率高
  - 缺点：
    - 如果并发量超过1000，会生成重复的ID

- 类snowflake算法

  一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求、（结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法）

  

  举例，假设某公司ID生成器服务的需求如下：

  （1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W
  （2）有2个机房，预计未来5年机房数量小于4个
  （3）每个机房机器数小于100台
  （4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个

  这样设计的64bit标识，可以保证：

  ![image-20200903174421239](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20200903174421239.png)

  优点：

  - 每个业务线、每个机房、每个机器生成的ID都是不同的
  - 同一个机器，每个毫秒内生成的ID都是不同的
  - 同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的

  - 将毫秒数放在最高位，保证生成的ID是趋势递增的

  **最后一个容易忽略的问题：**

  生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。

  又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。

**利用单点序列化，可以保证多机相同时序**

- 先在一台机器上序列化操作

- 再将操作序列分发到所有的机器，以保证多机的操作序列是一致的，最终数据是一致的

**典型场景一：数据库主从同步**

![image-20200903175306895](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20200903175306895.png)

上游分别发起了op1,op2,op3三个操作，主库master来序列化所有的SQL写操作op3,op1,op2，然后把相同的序列发送给从库slave执行，以保证所有数据库数据的一致性，就是利用“单点序列化”这个思路。

**典型场景二：GFS中文件的一致性**

![image-20200903175357158](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20200903175357158.png)



**【单对单聊天，怎么保证发送顺序与接收顺序一致】**



